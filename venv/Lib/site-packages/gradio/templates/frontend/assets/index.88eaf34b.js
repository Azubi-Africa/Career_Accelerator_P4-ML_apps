import { S as SvelteComponent, i as init, s as safe_not_equal, a as svg_element, b as attr, c as insert, d as append, n as noop, e as detach, f as element, t as toggle_class, l as listen, g as is_function, p as prevent_default, h as text, j as set_data, r as run_all, k as empty, m as space, o as destroy_each, q as create_component, u as mount_component, v as transition_in, w as transition_out, x as destroy_component, y as group_outros, z as check_outros, A as createEventDispatcher, B as spring, C as subscribe, D as binding_callbacks, E as onDestroy, F as bubble, G as add_flush_callback, H as src_url_equal, I as action_destroyer, J as bind, K as component_subscribe, X, L as assign, M as StatusTracker, N as get_spread_update, O as get_spread_object } from './index.7642b5d6.js';
import { U as Upload } from './Upload.a3347141.js';
import { M as ModifyUpload } from './ModifyUpload.98a915b6.js';
import { B as BlockLabel } from './BlockLabel.23eaa3bf.js';
import { B as Block } from './Block.c3963771.js';
import { n as normalise_file } from './utils.49185b04.js';
import './styles.db46e346.js';

/* home/runner/work/gradio/gradio/ui/packages/icons/src/Music.svelte generated by Svelte v3.49.0 */

function create_fragment$5(ctx) {
	let svg;
	let path;
	let circle0;
	let circle1;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			attr(path, "d", "M9 18V5l12-2v13");
			attr(circle0, "cx", "6");
			attr(circle0, "cy", "18");
			attr(circle0, "r", "3");
			attr(circle1, "cx", "18");
			attr(circle1, "cy", "16");
			attr(circle1, "r", "3");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "100%");
			attr(svg, "height", "100%");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", "1.5");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", "feather feather-music");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, circle0);
			append(svg, circle1);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class Music extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$5, safe_not_equal, {});
	}
}

var RangePips_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/ui/node_modules/.pnpm/svelte-range-slider-pips@2.0.2/node_modules/svelte-range-slider-pips/src/RangePips.svelte generated by Svelte v3.49.0 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[27] = list[i];
	child_ctx[29] = i;
	return child_ctx;
}

// (173:2) {#if ( all && first !== false ) || first }
function create_if_block_9(ctx) {
	let span;
	let span_style_value;
	let mounted;
	let dispose;
	let if_block = (/*all*/ ctx[6] === 'label' || /*first*/ ctx[7] === 'label') && create_if_block_10(ctx);

	return {
		c() {
			span = element("span");
			if (if_block) if_block.c();
			attr(span, "class", "pip first");
			attr(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 0%;"));
			toggle_class(span, "selected", /*isSelected*/ ctx[17](/*min*/ ctx[0]));
			toggle_class(span, "in-range", /*inRange*/ ctx[16](/*min*/ ctx[0]));
		},
		m(target, anchor) {
			insert(target, span, anchor);
			if (if_block) if_block.m(span, null);

			if (!mounted) {
				dispose = [
					listen(span, "click", function () {
						if (is_function(/*labelClick*/ ctx[20](/*min*/ ctx[0]))) /*labelClick*/ ctx[20](/*min*/ ctx[0]).apply(this, arguments);
					}),
					listen(span, "touchend", prevent_default(function () {
						if (is_function(/*labelClick*/ ctx[20](/*min*/ ctx[0]))) /*labelClick*/ ctx[20](/*min*/ ctx[0]).apply(this, arguments);
					}))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*all*/ ctx[6] === 'label' || /*first*/ ctx[7] === 'label') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_10(ctx);
					if_block.c();
					if_block.m(span, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*orientationStart*/ 16384 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 0%;"))) {
				attr(span, "style", span_style_value);
			}

			if (dirty & /*isSelected, min*/ 131073) {
				toggle_class(span, "selected", /*isSelected*/ ctx[17](/*min*/ ctx[0]));
			}

			if (dirty & /*inRange, min*/ 65537) {
				toggle_class(span, "in-range", /*inRange*/ ctx[16](/*min*/ ctx[0]));
			}
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (182:6) {#if all === 'label' || first === 'label'}
function create_if_block_10(ctx) {
	let span;
	let t_value = /*formatter*/ ctx[12](/*min*/ ctx[0], 0, 0) + "";
	let t;
	let if_block0 = /*prefix*/ ctx[10] && create_if_block_12(ctx);
	let if_block1 = /*suffix*/ ctx[11] && create_if_block_11(ctx);

	return {
		c() {
			span = element("span");
			if (if_block0) if_block0.c();
			t = text(t_value);
			if (if_block1) if_block1.c();
			attr(span, "class", "pipVal");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append(span, t);
			if (if_block1) if_block1.m(span, null);
		},
		p(ctx, dirty) {
			if (/*prefix*/ ctx[10]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_12(ctx);
					if_block0.c();
					if_block0.m(span, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*formatter, min*/ 4097 && t_value !== (t_value = /*formatter*/ ctx[12](/*min*/ ctx[0], 0, 0) + "")) set_data(t, t_value);

			if (/*suffix*/ ctx[11]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_11(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (184:10) {#if prefix}
function create_if_block_12(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text(/*prefix*/ ctx[10]);
			attr(span, "class", "pipVal-prefix");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*prefix*/ 1024) set_data(t, /*prefix*/ ctx[10]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (184:90) {#if suffix}
function create_if_block_11(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text(/*suffix*/ ctx[11]);
			attr(span, "class", "pipVal-suffix");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*suffix*/ 2048) set_data(t, /*suffix*/ ctx[11]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (190:2) {#if ( all && rest !== false ) || rest}
function create_if_block_4$2(ctx) {
	let each_1_anchor;
	let each_value = Array(/*pipCount*/ ctx[19] + 1);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*orientationStart, percentOf, pipVal, isSelected, inRange, labelClick, suffix, formatter, prefix, all, rest, min, max, pipCount*/ 2088515) {
				each_value = Array(/*pipCount*/ ctx[19] + 1);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (192:6) {#if pipVal(i) !== min && pipVal(i) !== max}
function create_if_block_5(ctx) {
	let span;
	let t;
	let span_style_value;
	let mounted;
	let dispose;
	let if_block = (/*all*/ ctx[6] === 'label' || /*rest*/ ctx[9] === 'label') && create_if_block_6(ctx);

	return {
		c() {
			span = element("span");
			if (if_block) if_block.c();
			t = space();
			attr(span, "class", "pip");
			attr(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[14] + ": " + /*percentOf*/ ctx[15](/*pipVal*/ ctx[18](/*i*/ ctx[29])) + "%;"));
			toggle_class(span, "selected", /*isSelected*/ ctx[17](/*pipVal*/ ctx[18](/*i*/ ctx[29])));
			toggle_class(span, "in-range", /*inRange*/ ctx[16](/*pipVal*/ ctx[18](/*i*/ ctx[29])));
		},
		m(target, anchor) {
			insert(target, span, anchor);
			if (if_block) if_block.m(span, null);
			append(span, t);

			if (!mounted) {
				dispose = [
					listen(span, "click", function () {
						if (is_function(/*labelClick*/ ctx[20](/*pipVal*/ ctx[18](/*i*/ ctx[29])))) /*labelClick*/ ctx[20](/*pipVal*/ ctx[18](/*i*/ ctx[29])).apply(this, arguments);
					}),
					listen(span, "touchend", prevent_default(function () {
						if (is_function(/*labelClick*/ ctx[20](/*pipVal*/ ctx[18](/*i*/ ctx[29])))) /*labelClick*/ ctx[20](/*pipVal*/ ctx[18](/*i*/ ctx[29])).apply(this, arguments);
					}))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*all*/ ctx[6] === 'label' || /*rest*/ ctx[9] === 'label') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_6(ctx);
					if_block.c();
					if_block.m(span, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*orientationStart, percentOf, pipVal*/ 311296 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[14] + ": " + /*percentOf*/ ctx[15](/*pipVal*/ ctx[18](/*i*/ ctx[29])) + "%;"))) {
				attr(span, "style", span_style_value);
			}

			if (dirty & /*isSelected, pipVal*/ 393216) {
				toggle_class(span, "selected", /*isSelected*/ ctx[17](/*pipVal*/ ctx[18](/*i*/ ctx[29])));
			}

			if (dirty & /*inRange, pipVal*/ 327680) {
				toggle_class(span, "in-range", /*inRange*/ ctx[16](/*pipVal*/ ctx[18](/*i*/ ctx[29])));
			}
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (201:10) {#if all === 'label' || rest === 'label'}
function create_if_block_6(ctx) {
	let span;
	let t_value = /*formatter*/ ctx[12](/*pipVal*/ ctx[18](/*i*/ ctx[29]), /*i*/ ctx[29], /*percentOf*/ ctx[15](/*pipVal*/ ctx[18](/*i*/ ctx[29]))) + "";
	let t;
	let if_block0 = /*prefix*/ ctx[10] && create_if_block_8(ctx);
	let if_block1 = /*suffix*/ ctx[11] && create_if_block_7(ctx);

	return {
		c() {
			span = element("span");
			if (if_block0) if_block0.c();
			t = text(t_value);
			if (if_block1) if_block1.c();
			attr(span, "class", "pipVal");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append(span, t);
			if (if_block1) if_block1.m(span, null);
		},
		p(ctx, dirty) {
			if (/*prefix*/ ctx[10]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_8(ctx);
					if_block0.c();
					if_block0.m(span, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*formatter, pipVal, percentOf*/ 299008 && t_value !== (t_value = /*formatter*/ ctx[12](/*pipVal*/ ctx[18](/*i*/ ctx[29]), /*i*/ ctx[29], /*percentOf*/ ctx[15](/*pipVal*/ ctx[18](/*i*/ ctx[29]))) + "")) set_data(t, t_value);

			if (/*suffix*/ ctx[11]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_7(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (203:14) {#if prefix}
function create_if_block_8(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text(/*prefix*/ ctx[10]);
			attr(span, "class", "pipVal-prefix");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*prefix*/ 1024) set_data(t, /*prefix*/ ctx[10]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (203:119) {#if suffix}
function create_if_block_7(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text(/*suffix*/ ctx[11]);
			attr(span, "class", "pipVal-suffix");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*suffix*/ 2048) set_data(t, /*suffix*/ ctx[11]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (191:4) {#each Array(pipCount + 1) as _, i}
function create_each_block$1(ctx) {
	let show_if = /*pipVal*/ ctx[18](/*i*/ ctx[29]) !== /*min*/ ctx[0] && /*pipVal*/ ctx[18](/*i*/ ctx[29]) !== /*max*/ ctx[1];
	let if_block_anchor;
	let if_block = show_if && create_if_block_5(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*pipVal, min, max*/ 262147) show_if = /*pipVal*/ ctx[18](/*i*/ ctx[29]) !== /*min*/ ctx[0] && /*pipVal*/ ctx[18](/*i*/ ctx[29]) !== /*max*/ ctx[1];

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_5(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (211:2) {#if ( all && last !== false ) || last}
function create_if_block$4(ctx) {
	let span;
	let span_style_value;
	let mounted;
	let dispose;
	let if_block = (/*all*/ ctx[6] === 'label' || /*last*/ ctx[8] === 'label') && create_if_block_1$2(ctx);

	return {
		c() {
			span = element("span");
			if (if_block) if_block.c();
			attr(span, "class", "pip last");
			attr(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 100%;"));
			toggle_class(span, "selected", /*isSelected*/ ctx[17](/*max*/ ctx[1]));
			toggle_class(span, "in-range", /*inRange*/ ctx[16](/*max*/ ctx[1]));
		},
		m(target, anchor) {
			insert(target, span, anchor);
			if (if_block) if_block.m(span, null);

			if (!mounted) {
				dispose = [
					listen(span, "click", function () {
						if (is_function(/*labelClick*/ ctx[20](/*max*/ ctx[1]))) /*labelClick*/ ctx[20](/*max*/ ctx[1]).apply(this, arguments);
					}),
					listen(span, "touchend", prevent_default(function () {
						if (is_function(/*labelClick*/ ctx[20](/*max*/ ctx[1]))) /*labelClick*/ ctx[20](/*max*/ ctx[1]).apply(this, arguments);
					}))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*all*/ ctx[6] === 'label' || /*last*/ ctx[8] === 'label') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$2(ctx);
					if_block.c();
					if_block.m(span, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*orientationStart*/ 16384 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 100%;"))) {
				attr(span, "style", span_style_value);
			}

			if (dirty & /*isSelected, max*/ 131074) {
				toggle_class(span, "selected", /*isSelected*/ ctx[17](/*max*/ ctx[1]));
			}

			if (dirty & /*inRange, max*/ 65538) {
				toggle_class(span, "in-range", /*inRange*/ ctx[16](/*max*/ ctx[1]));
			}
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (220:6) {#if all === 'label' || last === 'label'}
function create_if_block_1$2(ctx) {
	let span;
	let t_value = /*formatter*/ ctx[12](/*max*/ ctx[1], /*pipCount*/ ctx[19], 100) + "";
	let t;
	let if_block0 = /*prefix*/ ctx[10] && create_if_block_3$2(ctx);
	let if_block1 = /*suffix*/ ctx[11] && create_if_block_2$2(ctx);

	return {
		c() {
			span = element("span");
			if (if_block0) if_block0.c();
			t = text(t_value);
			if (if_block1) if_block1.c();
			attr(span, "class", "pipVal");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append(span, t);
			if (if_block1) if_block1.m(span, null);
		},
		p(ctx, dirty) {
			if (/*prefix*/ ctx[10]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3$2(ctx);
					if_block0.c();
					if_block0.m(span, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*formatter, max, pipCount*/ 528386 && t_value !== (t_value = /*formatter*/ ctx[12](/*max*/ ctx[1], /*pipCount*/ ctx[19], 100) + "")) set_data(t, t_value);

			if (/*suffix*/ ctx[11]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2$2(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (222:10) {#if prefix}
function create_if_block_3$2(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text(/*prefix*/ ctx[10]);
			attr(span, "class", "pipVal-prefix");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*prefix*/ 1024) set_data(t, /*prefix*/ ctx[10]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (222:99) {#if suffix}
function create_if_block_2$2(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text(/*suffix*/ ctx[11]);
			attr(span, "class", "pipVal-suffix");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*suffix*/ 2048) set_data(t, /*suffix*/ ctx[11]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

function create_fragment$4(ctx) {
	let div;
	let t0;
	let t1;
	let if_block0 = (/*all*/ ctx[6] && /*first*/ ctx[7] !== false || /*first*/ ctx[7]) && create_if_block_9(ctx);
	let if_block1 = (/*all*/ ctx[6] && /*rest*/ ctx[9] !== false || /*rest*/ ctx[9]) && create_if_block_4$2(ctx);
	let if_block2 = (/*all*/ ctx[6] && /*last*/ ctx[8] !== false || /*last*/ ctx[8]) && create_if_block$4(ctx);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			attr(div, "class", "rangePips");
			toggle_class(div, "disabled", /*disabled*/ ctx[5]);
			toggle_class(div, "hoverable", /*hoverable*/ ctx[4]);
			toggle_class(div, "vertical", /*vertical*/ ctx[2]);
			toggle_class(div, "reversed", /*reversed*/ ctx[3]);
			toggle_class(div, "focus", /*focus*/ ctx[13]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append(div, t0);
			if (if_block1) if_block1.m(div, null);
			append(div, t1);
			if (if_block2) if_block2.m(div, null);
		},
		p(ctx, [dirty]) {
			if (/*all*/ ctx[6] && /*first*/ ctx[7] !== false || /*first*/ ctx[7]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_9(ctx);
					if_block0.c();
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*all*/ ctx[6] && /*rest*/ ctx[9] !== false || /*rest*/ ctx[9]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_4$2(ctx);
					if_block1.c();
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*all*/ ctx[6] && /*last*/ ctx[8] !== false || /*last*/ ctx[8]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block$4(ctx);
					if_block2.c();
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty & /*disabled*/ 32) {
				toggle_class(div, "disabled", /*disabled*/ ctx[5]);
			}

			if (dirty & /*hoverable*/ 16) {
				toggle_class(div, "hoverable", /*hoverable*/ ctx[4]);
			}

			if (dirty & /*vertical*/ 4) {
				toggle_class(div, "vertical", /*vertical*/ ctx[2]);
			}

			if (dirty & /*reversed*/ 8) {
				toggle_class(div, "reversed", /*reversed*/ ctx[3]);
			}

			if (dirty & /*focus*/ 8192) {
				toggle_class(div, "focus", /*focus*/ ctx[13]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let pipStep;
	let pipCount;
	let pipVal;
	let isSelected;
	let inRange;
	let { range = false } = $$props;
	let { min = 0 } = $$props;
	let { max = 100 } = $$props;
	let { step = 1 } = $$props;
	let { values = [(max + min) / 2] } = $$props;
	let { vertical = false } = $$props;
	let { reversed = false } = $$props;
	let { hoverable = true } = $$props;
	let { disabled = false } = $$props;
	let { pipstep = undefined } = $$props;
	let { all = true } = $$props;
	let { first = undefined } = $$props;
	let { last = undefined } = $$props;
	let { rest = undefined } = $$props;
	let { prefix = "" } = $$props;
	let { suffix = "" } = $$props;
	let { formatter = (v, i) => v } = $$props;
	let { focus = undefined } = $$props;
	let { orientationStart = undefined } = $$props;
	let { percentOf = undefined } = $$props;
	let { moveHandle = undefined } = $$props;

	function labelClick(val) {
		moveHandle(undefined, val);
	}

	$$self.$$set = $$props => {
		if ('range' in $$props) $$invalidate(21, range = $$props.range);
		if ('min' in $$props) $$invalidate(0, min = $$props.min);
		if ('max' in $$props) $$invalidate(1, max = $$props.max);
		if ('step' in $$props) $$invalidate(22, step = $$props.step);
		if ('values' in $$props) $$invalidate(23, values = $$props.values);
		if ('vertical' in $$props) $$invalidate(2, vertical = $$props.vertical);
		if ('reversed' in $$props) $$invalidate(3, reversed = $$props.reversed);
		if ('hoverable' in $$props) $$invalidate(4, hoverable = $$props.hoverable);
		if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
		if ('pipstep' in $$props) $$invalidate(24, pipstep = $$props.pipstep);
		if ('all' in $$props) $$invalidate(6, all = $$props.all);
		if ('first' in $$props) $$invalidate(7, first = $$props.first);
		if ('last' in $$props) $$invalidate(8, last = $$props.last);
		if ('rest' in $$props) $$invalidate(9, rest = $$props.rest);
		if ('prefix' in $$props) $$invalidate(10, prefix = $$props.prefix);
		if ('suffix' in $$props) $$invalidate(11, suffix = $$props.suffix);
		if ('formatter' in $$props) $$invalidate(12, formatter = $$props.formatter);
		if ('focus' in $$props) $$invalidate(13, focus = $$props.focus);
		if ('orientationStart' in $$props) $$invalidate(14, orientationStart = $$props.orientationStart);
		if ('percentOf' in $$props) $$invalidate(15, percentOf = $$props.percentOf);
		if ('moveHandle' in $$props) $$invalidate(25, moveHandle = $$props.moveHandle);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*pipstep, max, min, step, vertical*/ 20971527) {
			$$invalidate(26, pipStep = pipstep || ((max - min) / step >= (vertical ? 50 : 100)
			? (max - min) / (vertical ? 10 : 20)
			: 1));
		}

		if ($$self.$$.dirty & /*max, min, step, pipStep*/ 71303171) {
			$$invalidate(19, pipCount = parseInt((max - min) / (step * pipStep), 10));
		}

		if ($$self.$$.dirty & /*min, step, pipStep*/ 71303169) {
			$$invalidate(18, pipVal = function (val) {
				return min + val * step * pipStep;
			});
		}

		if ($$self.$$.dirty & /*values*/ 8388608) {
			$$invalidate(17, isSelected = function (val) {
				return values.some(v => v === val);
			});
		}

		if ($$self.$$.dirty & /*range, values*/ 10485760) {
			$$invalidate(16, inRange = function (val) {
				if (range === "min") {
					return values[0] > val;
				} else if (range === "max") {
					return values[0] < val;
				} else if (range) {
					return values[0] < val && values[1] > val;
				}
			});
		}
	};

	return [
		min,
		max,
		vertical,
		reversed,
		hoverable,
		disabled,
		all,
		first,
		last,
		rest,
		prefix,
		suffix,
		formatter,
		focus,
		orientationStart,
		percentOf,
		inRange,
		isSelected,
		pipVal,
		pipCount,
		labelClick,
		range,
		step,
		values,
		pipstep,
		moveHandle,
		pipStep
	];
}

class RangePips extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			range: 21,
			min: 0,
			max: 1,
			step: 22,
			values: 23,
			vertical: 2,
			reversed: 3,
			hoverable: 4,
			disabled: 5,
			pipstep: 24,
			all: 6,
			first: 7,
			last: 8,
			rest: 9,
			prefix: 10,
			suffix: 11,
			formatter: 12,
			focus: 13,
			orientationStart: 14,
			percentOf: 15,
			moveHandle: 25
		});
	}
}

var RangeSlider_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/ui/node_modules/.pnpm/svelte-range-slider-pips@2.0.2/node_modules/svelte-range-slider-pips/src/RangeSlider.svelte generated by Svelte v3.49.0 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[63] = list[i];
	child_ctx[65] = i;
	return child_ctx;
}

// (817:6) {#if float}
function create_if_block_2$1(ctx) {
	let span;
	let t_value = /*handleFormatter*/ ctx[21](/*value*/ ctx[63], /*index*/ ctx[65], /*percentOf*/ ctx[23](/*value*/ ctx[63])) + "";
	let t;
	let if_block0 = /*prefix*/ ctx[18] && create_if_block_4$1(ctx);
	let if_block1 = /*suffix*/ ctx[19] && create_if_block_3$1(ctx);

	return {
		c() {
			span = element("span");
			if (if_block0) if_block0.c();
			t = text(t_value);
			if (if_block1) if_block1.c();
			attr(span, "class", "rangeFloat");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append(span, t);
			if (if_block1) if_block1.m(span, null);
		},
		p(ctx, dirty) {
			if (/*prefix*/ ctx[18]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4$1(ctx);
					if_block0.c();
					if_block0.m(span, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*handleFormatter, values, percentOf*/ 10485761 && t_value !== (t_value = /*handleFormatter*/ ctx[21](/*value*/ ctx[63], /*index*/ ctx[65], /*percentOf*/ ctx[23](/*value*/ ctx[63])) + "")) set_data(t, t_value);

			if (/*suffix*/ ctx[19]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3$1(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (819:10) {#if prefix}
function create_if_block_4$1(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text(/*prefix*/ ctx[18]);
			attr(span, "class", "rangeFloat-prefix");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*prefix*/ 262144) set_data(t, /*prefix*/ ctx[18]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (819:121) {#if suffix}
function create_if_block_3$1(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text(/*suffix*/ ctx[19]);
			attr(span, "class", "rangeFloat-suffix");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*suffix*/ 524288) set_data(t, /*suffix*/ ctx[19]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (796:2) {#each values as value, index}
function create_each_block(ctx) {
	let span1;
	let span0;
	let t;
	let span1_data_handle_value;
	let span1_style_value;
	let span1_aria_valuemin_value;
	let span1_aria_valuemax_value;
	let span1_aria_valuenow_value;
	let span1_aria_valuetext_value;
	let span1_aria_orientation_value;
	let span1_tabindex_value;
	let mounted;
	let dispose;
	let if_block = /*float*/ ctx[7] && create_if_block_2$1(ctx);

	return {
		c() {
			span1 = element("span");
			span0 = element("span");
			t = space();
			if (if_block) if_block.c();
			attr(span0, "class", "rangeNub");
			attr(span1, "role", "slider");
			attr(span1, "class", "rangeHandle");
			attr(span1, "data-handle", span1_data_handle_value = /*index*/ ctx[65]);
			attr(span1, "style", span1_style_value = "" + (/*orientationStart*/ ctx[28] + ": " + /*$springPositions*/ ctx[29][/*index*/ ctx[65]] + "%; z-index: " + (/*activeHandle*/ ctx[26] === /*index*/ ctx[65] ? 3 : 2) + ";"));

			attr(span1, "aria-valuemin", span1_aria_valuemin_value = /*range*/ ctx[2] === true && /*index*/ ctx[65] === 1
			? /*values*/ ctx[0][0]
			: /*min*/ ctx[3]);

			attr(span1, "aria-valuemax", span1_aria_valuemax_value = /*range*/ ctx[2] === true && /*index*/ ctx[65] === 0
			? /*values*/ ctx[0][1]
			: /*max*/ ctx[4]);

			attr(span1, "aria-valuenow", span1_aria_valuenow_value = /*value*/ ctx[63]);
			attr(span1, "aria-valuetext", span1_aria_valuetext_value = "" + (/*prefix*/ ctx[18] + /*handleFormatter*/ ctx[21](/*value*/ ctx[63], /*index*/ ctx[65], /*percentOf*/ ctx[23](/*value*/ ctx[63])) + /*suffix*/ ctx[19]));
			attr(span1, "aria-orientation", span1_aria_orientation_value = /*vertical*/ ctx[6] ? 'vertical' : 'horizontal');
			attr(span1, "aria-disabled", /*disabled*/ ctx[10]);
			attr(span1, "disabled", /*disabled*/ ctx[10]);
			attr(span1, "tabindex", span1_tabindex_value = /*disabled*/ ctx[10] ? -1 : 0);
			toggle_class(span1, "active", /*focus*/ ctx[24] && /*activeHandle*/ ctx[26] === /*index*/ ctx[65]);
			toggle_class(span1, "press", /*handlePressed*/ ctx[25] && /*activeHandle*/ ctx[26] === /*index*/ ctx[65]);
		},
		m(target, anchor) {
			insert(target, span1, anchor);
			append(span1, span0);
			append(span1, t);
			if (if_block) if_block.m(span1, null);

			if (!mounted) {
				dispose = [
					listen(span1, "blur", /*sliderBlurHandle*/ ctx[33]),
					listen(span1, "focus", /*sliderFocusHandle*/ ctx[34]),
					listen(span1, "keydown", /*sliderKeydown*/ ctx[35])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*float*/ ctx[7]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2$1(ctx);
					if_block.c();
					if_block.m(span1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*orientationStart, $springPositions, activeHandle*/ 872415232 && span1_style_value !== (span1_style_value = "" + (/*orientationStart*/ ctx[28] + ": " + /*$springPositions*/ ctx[29][/*index*/ ctx[65]] + "%; z-index: " + (/*activeHandle*/ ctx[26] === /*index*/ ctx[65] ? 3 : 2) + ";"))) {
				attr(span1, "style", span1_style_value);
			}

			if (dirty[0] & /*range, values, min*/ 13 && span1_aria_valuemin_value !== (span1_aria_valuemin_value = /*range*/ ctx[2] === true && /*index*/ ctx[65] === 1
			? /*values*/ ctx[0][0]
			: /*min*/ ctx[3])) {
				attr(span1, "aria-valuemin", span1_aria_valuemin_value);
			}

			if (dirty[0] & /*range, values, max*/ 21 && span1_aria_valuemax_value !== (span1_aria_valuemax_value = /*range*/ ctx[2] === true && /*index*/ ctx[65] === 0
			? /*values*/ ctx[0][1]
			: /*max*/ ctx[4])) {
				attr(span1, "aria-valuemax", span1_aria_valuemax_value);
			}

			if (dirty[0] & /*values*/ 1 && span1_aria_valuenow_value !== (span1_aria_valuenow_value = /*value*/ ctx[63])) {
				attr(span1, "aria-valuenow", span1_aria_valuenow_value);
			}

			if (dirty[0] & /*prefix, handleFormatter, values, percentOf, suffix*/ 11272193 && span1_aria_valuetext_value !== (span1_aria_valuetext_value = "" + (/*prefix*/ ctx[18] + /*handleFormatter*/ ctx[21](/*value*/ ctx[63], /*index*/ ctx[65], /*percentOf*/ ctx[23](/*value*/ ctx[63])) + /*suffix*/ ctx[19]))) {
				attr(span1, "aria-valuetext", span1_aria_valuetext_value);
			}

			if (dirty[0] & /*vertical*/ 64 && span1_aria_orientation_value !== (span1_aria_orientation_value = /*vertical*/ ctx[6] ? 'vertical' : 'horizontal')) {
				attr(span1, "aria-orientation", span1_aria_orientation_value);
			}

			if (dirty[0] & /*disabled*/ 1024) {
				attr(span1, "aria-disabled", /*disabled*/ ctx[10]);
			}

			if (dirty[0] & /*disabled*/ 1024) {
				attr(span1, "disabled", /*disabled*/ ctx[10]);
			}

			if (dirty[0] & /*disabled*/ 1024 && span1_tabindex_value !== (span1_tabindex_value = /*disabled*/ ctx[10] ? -1 : 0)) {
				attr(span1, "tabindex", span1_tabindex_value);
			}

			if (dirty[0] & /*focus, activeHandle*/ 83886080) {
				toggle_class(span1, "active", /*focus*/ ctx[24] && /*activeHandle*/ ctx[26] === /*index*/ ctx[65]);
			}

			if (dirty[0] & /*handlePressed, activeHandle*/ 100663296) {
				toggle_class(span1, "press", /*handlePressed*/ ctx[25] && /*activeHandle*/ ctx[26] === /*index*/ ctx[65]);
			}
		},
		d(detaching) {
			if (detaching) detach(span1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (824:2) {#if range}
function create_if_block_1$1(ctx) {
	let span;
	let span_style_value;

	return {
		c() {
			span = element("span");
			attr(span, "class", "rangeBar");
			attr(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[28] + ": " + /*rangeStart*/ ctx[31](/*$springPositions*/ ctx[29]) + "%; " + /*orientationEnd*/ ctx[27] + ": " + /*rangeEnd*/ ctx[32](/*$springPositions*/ ctx[29]) + "%;"));
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*orientationStart, $springPositions, orientationEnd*/ 939524096 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[28] + ": " + /*rangeStart*/ ctx[31](/*$springPositions*/ ctx[29]) + "%; " + /*orientationEnd*/ ctx[27] + ": " + /*rangeEnd*/ ctx[32](/*$springPositions*/ ctx[29]) + "%;"))) {
				attr(span, "style", span_style_value);
			}
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (830:2) {#if pips}
function create_if_block$3(ctx) {
	let rangepips;
	let current;

	rangepips = new RangePips({
			props: {
				values: /*values*/ ctx[0],
				min: /*min*/ ctx[3],
				max: /*max*/ ctx[4],
				step: /*step*/ ctx[5],
				range: /*range*/ ctx[2],
				vertical: /*vertical*/ ctx[6],
				reversed: /*reversed*/ ctx[8],
				orientationStart: /*orientationStart*/ ctx[28],
				hoverable: /*hoverable*/ ctx[9],
				disabled: /*disabled*/ ctx[10],
				all: /*all*/ ctx[13],
				first: /*first*/ ctx[14],
				last: /*last*/ ctx[15],
				rest: /*rest*/ ctx[16],
				pipstep: /*pipstep*/ ctx[12],
				prefix: /*prefix*/ ctx[18],
				suffix: /*suffix*/ ctx[19],
				formatter: /*formatter*/ ctx[20],
				focus: /*focus*/ ctx[24],
				percentOf: /*percentOf*/ ctx[23],
				moveHandle: /*moveHandle*/ ctx[30]
			}
		});

	return {
		c() {
			create_component(rangepips.$$.fragment);
		},
		m(target, anchor) {
			mount_component(rangepips, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const rangepips_changes = {};
			if (dirty[0] & /*values*/ 1) rangepips_changes.values = /*values*/ ctx[0];
			if (dirty[0] & /*min*/ 8) rangepips_changes.min = /*min*/ ctx[3];
			if (dirty[0] & /*max*/ 16) rangepips_changes.max = /*max*/ ctx[4];
			if (dirty[0] & /*step*/ 32) rangepips_changes.step = /*step*/ ctx[5];
			if (dirty[0] & /*range*/ 4) rangepips_changes.range = /*range*/ ctx[2];
			if (dirty[0] & /*vertical*/ 64) rangepips_changes.vertical = /*vertical*/ ctx[6];
			if (dirty[0] & /*reversed*/ 256) rangepips_changes.reversed = /*reversed*/ ctx[8];
			if (dirty[0] & /*orientationStart*/ 268435456) rangepips_changes.orientationStart = /*orientationStart*/ ctx[28];
			if (dirty[0] & /*hoverable*/ 512) rangepips_changes.hoverable = /*hoverable*/ ctx[9];
			if (dirty[0] & /*disabled*/ 1024) rangepips_changes.disabled = /*disabled*/ ctx[10];
			if (dirty[0] & /*all*/ 8192) rangepips_changes.all = /*all*/ ctx[13];
			if (dirty[0] & /*first*/ 16384) rangepips_changes.first = /*first*/ ctx[14];
			if (dirty[0] & /*last*/ 32768) rangepips_changes.last = /*last*/ ctx[15];
			if (dirty[0] & /*rest*/ 65536) rangepips_changes.rest = /*rest*/ ctx[16];
			if (dirty[0] & /*pipstep*/ 4096) rangepips_changes.pipstep = /*pipstep*/ ctx[12];
			if (dirty[0] & /*prefix*/ 262144) rangepips_changes.prefix = /*prefix*/ ctx[18];
			if (dirty[0] & /*suffix*/ 524288) rangepips_changes.suffix = /*suffix*/ ctx[19];
			if (dirty[0] & /*formatter*/ 1048576) rangepips_changes.formatter = /*formatter*/ ctx[20];
			if (dirty[0] & /*focus*/ 16777216) rangepips_changes.focus = /*focus*/ ctx[24];
			if (dirty[0] & /*percentOf*/ 8388608) rangepips_changes.percentOf = /*percentOf*/ ctx[23];
			rangepips.$set(rangepips_changes);
		},
		i(local) {
			if (current) return;
			transition_in(rangepips.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(rangepips.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(rangepips, detaching);
		}
	};
}

function create_fragment$3(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	let each_value = /*values*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	let if_block0 = /*range*/ ctx[2] && create_if_block_1$1(ctx);
	let if_block1 = /*pips*/ ctx[11] && create_if_block$3(ctx);

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			attr(div, "id", /*id*/ ctx[17]);
			attr(div, "class", "rangeSlider");
			toggle_class(div, "range", /*range*/ ctx[2]);
			toggle_class(div, "disabled", /*disabled*/ ctx[10]);
			toggle_class(div, "hoverable", /*hoverable*/ ctx[9]);
			toggle_class(div, "vertical", /*vertical*/ ctx[6]);
			toggle_class(div, "reversed", /*reversed*/ ctx[8]);
			toggle_class(div, "focus", /*focus*/ ctx[24]);
			toggle_class(div, "min", /*range*/ ctx[2] === 'min');
			toggle_class(div, "max", /*range*/ ctx[2] === 'max');
			toggle_class(div, "pips", /*pips*/ ctx[11]);
			toggle_class(div, "pip-labels", /*all*/ ctx[13] === 'label' || /*first*/ ctx[14] === 'label' || /*last*/ ctx[15] === 'label' || /*rest*/ ctx[16] === 'label');
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append(div, t0);
			if (if_block0) if_block0.m(div, null);
			append(div, t1);
			if (if_block1) if_block1.m(div, null);
			/*div_binding*/ ctx[49](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen(window, "mousedown", /*bodyInteractStart*/ ctx[38]),
					listen(window, "touchstart", /*bodyInteractStart*/ ctx[38]),
					listen(window, "mousemove", /*bodyInteract*/ ctx[39]),
					listen(window, "touchmove", /*bodyInteract*/ ctx[39]),
					listen(window, "mouseup", /*bodyMouseUp*/ ctx[40]),
					listen(window, "touchend", /*bodyTouchEnd*/ ctx[41]),
					listen(window, "keydown", /*bodyKeyDown*/ ctx[42]),
					listen(div, "mousedown", /*sliderInteractStart*/ ctx[36]),
					listen(div, "mouseup", /*sliderInteractEnd*/ ctx[37]),
					listen(div, "touchstart", prevent_default(/*sliderInteractStart*/ ctx[36])),
					listen(div, "touchend", prevent_default(/*sliderInteractEnd*/ ctx[37]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*orientationStart, $springPositions, activeHandle, range, values, min, max, prefix, handleFormatter, percentOf, suffix, vertical, disabled, focus, handlePressed, float*/ 934020317 | dirty[1] & /*sliderBlurHandle, sliderFocusHandle, sliderKeydown*/ 28) {
				each_value = /*values*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, t0);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (/*range*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$1(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*pips*/ ctx[11]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*pips*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*id*/ 131072) {
				attr(div, "id", /*id*/ ctx[17]);
			}

			if (dirty[0] & /*range*/ 4) {
				toggle_class(div, "range", /*range*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 1024) {
				toggle_class(div, "disabled", /*disabled*/ ctx[10]);
			}

			if (dirty[0] & /*hoverable*/ 512) {
				toggle_class(div, "hoverable", /*hoverable*/ ctx[9]);
			}

			if (dirty[0] & /*vertical*/ 64) {
				toggle_class(div, "vertical", /*vertical*/ ctx[6]);
			}

			if (dirty[0] & /*reversed*/ 256) {
				toggle_class(div, "reversed", /*reversed*/ ctx[8]);
			}

			if (dirty[0] & /*focus*/ 16777216) {
				toggle_class(div, "focus", /*focus*/ ctx[24]);
			}

			if (dirty[0] & /*range*/ 4) {
				toggle_class(div, "min", /*range*/ ctx[2] === 'min');
			}

			if (dirty[0] & /*range*/ 4) {
				toggle_class(div, "max", /*range*/ ctx[2] === 'max');
			}

			if (dirty[0] & /*pips*/ 2048) {
				toggle_class(div, "pips", /*pips*/ ctx[11]);
			}

			if (dirty[0] & /*all, first, last, rest*/ 122880) {
				toggle_class(div, "pip-labels", /*all*/ ctx[13] === 'label' || /*first*/ ctx[14] === 'label' || /*last*/ ctx[15] === 'label' || /*rest*/ ctx[16] === 'label');
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			/*div_binding*/ ctx[49](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function index(el) {
	if (!el) return -1;
	var i = 0;

	while (el = el.previousElementSibling) {
		i++;
	}

	return i;
}

/**
 * normalise a mouse or touch event to return the
 * client (x/y) object for that event
 * @param {event} e a mouse/touch event to normalise
 * @returns {object} normalised event client object (x,y)
 **/
function normalisedClient(e) {
	if (e.type.includes("touch")) {
		return e.touches[0];
	} else {
		return e;
	}
}

function instance$3($$self, $$props, $$invalidate) {
	let percentOf;
	let clampValue;
	let alignValueToStep;
	let orientationStart;
	let orientationEnd;

	let $springPositions,
		$$unsubscribe_springPositions = noop,
		$$subscribe_springPositions = () => ($$unsubscribe_springPositions(), $$unsubscribe_springPositions = subscribe(springPositions, $$value => $$invalidate(29, $springPositions = $$value)), springPositions);

	$$self.$$.on_destroy.push(() => $$unsubscribe_springPositions());
	let { slider } = $$props;
	let { range = false } = $$props;
	let { pushy = false } = $$props;
	let { min = 0 } = $$props;
	let { max = 100 } = $$props;
	let { step = 1 } = $$props;
	let { values = [(max + min) / 2] } = $$props;
	let { vertical = false } = $$props;
	let { float = false } = $$props;
	let { reversed = false } = $$props;
	let { hoverable = true } = $$props;
	let { disabled = false } = $$props;
	let { pips = false } = $$props;
	let { pipstep = undefined } = $$props;
	let { all = undefined } = $$props;
	let { first = undefined } = $$props;
	let { last = undefined } = $$props;
	let { rest = undefined } = $$props;
	let { id = undefined } = $$props;
	let { prefix = "" } = $$props;
	let { suffix = "" } = $$props;
	let { formatter = (v, i, p) => v } = $$props;
	let { handleFormatter = formatter } = $$props;
	let { precision = 2 } = $$props;
	let { springValues = { stiffness: 0.15, damping: 0.4 } } = $$props;

	// prepare dispatched events
	const dispatch = createEventDispatcher();

	// state management
	let valueLength = 0;

	let focus = false;
	let handleActivated = false;
	let handlePressed = false;
	let keyboardActive = false;
	let activeHandle = values.length - 1;
	let startValue;
	let previousValue;

	// copy the initial values in to a spring function which
	// will update every time the values array is modified
	let springPositions;

	/**
 * check if an element is a handle on the slider
 * @param {object} el dom object reference we want to check
 * @returns {boolean}
 **/
	function targetIsHandle(el) {
		const handles = slider.querySelectorAll(".handle");
		const isHandle = Array.prototype.includes.call(handles, el);
		const isChild = Array.prototype.some.call(handles, e => e.contains(el));
		return isHandle || isChild;
	}

	/**
 * trim the values array based on whether the property
 * for 'range' is 'min', 'max', or truthy. This is because we
 * do not want more than one handle for a min/max range, and we do
 * not want more than two handles for a true range.
 * @param {array} values the input values for the rangeSlider
 * @return {array} the range array for creating a rangeSlider
 **/
	function trimRange(values) {
		if (range === "min" || range === "max") {
			return values.slice(0, 1);
		} else if (range) {
			return values.slice(0, 2);
		} else {
			return values;
		}
	}

	/**
 * helper to return the slider dimensions for finding
 * the closest handle to user interaction
 * @return {object} the range slider DOM client rect
 **/
	function getSliderDimensions() {
		return slider.getBoundingClientRect();
	}

	/**
 * helper to return closest handle to user interaction
 * @param {object} clientPos the client{x,y} positions to check against
 * @return {number} the index of the closest handle to clientPos
 **/
	function getClosestHandle(clientPos) {
		// first make sure we have the latest dimensions
		// of the slider, as it may have changed size
		const dims = getSliderDimensions();

		// calculate the interaction position, percent and value
		let handlePos = 0;

		let handlePercent = 0;
		let handleVal = 0;

		if (vertical) {
			handlePos = clientPos.clientY - dims.top;
			handlePercent = handlePos / dims.height * 100;
			handlePercent = reversed ? handlePercent : 100 - handlePercent;
		} else {
			handlePos = clientPos.clientX - dims.left;
			handlePercent = handlePos / dims.width * 100;
			handlePercent = reversed ? 100 - handlePercent : handlePercent;
		}

		handleVal = (max - min) / 100 * handlePercent + min;
		let closest;

		// if we have a range, and the handles are at the same
		// position, we want a simple check if the interaction
		// value is greater than return the second handle
		if (range === true && values[0] === values[1]) {
			if (handleVal > values[1]) {
				return 1;
			} else {
				return 0;
			}
		} else // we sort the handles values, and return the first one closest
		// to the interaction value
		{
			closest = values.indexOf([...values].sort((a, b) => Math.abs(handleVal - a) - Math.abs(handleVal - b))[0]); // if there are multiple handles, and not a range, then
		}

		return closest;
	}

	/**
 * take the interaction position on the slider, convert
 * it to a value on the range, and then send that value
 * through to the moveHandle() method to set the active
 * handle's position
 * @param {object} clientPos the client{x,y} of the interaction
 **/
	function handleInteract(clientPos) {
		// first make sure we have the latest dimensions
		// of the slider, as it may have changed size
		const dims = getSliderDimensions();

		// calculate the interaction position, percent and value
		let handlePos = 0;

		let handlePercent = 0;
		let handleVal = 0;

		if (vertical) {
			handlePos = clientPos.clientY - dims.top;
			handlePercent = handlePos / dims.height * 100;
			handlePercent = reversed ? handlePercent : 100 - handlePercent;
		} else {
			handlePos = clientPos.clientX - dims.left;
			handlePercent = handlePos / dims.width * 100;
			handlePercent = reversed ? 100 - handlePercent : handlePercent;
		}

		handleVal = (max - min) / 100 * handlePercent + min;

		// move handle to the value
		moveHandle(activeHandle, handleVal);
	}

	/**
 * move a handle to a specific value, respecting the clamp/align rules
 * @param {number} index the index of the handle we want to move
 * @param {number} value the value to move the handle to
 * @return {number} the value that was moved to (after alignment/clamping)
 **/
	function moveHandle(index, value) {
		// align & clamp the value so we're not doing extra
		// calculation on an out-of-range value down below
		value = alignValueToStep(value);

		// use the active handle if handle index is not provided
		if (typeof index === 'undefined') {
			index = activeHandle;
		}

		// if this is a range slider perform special checks
		if (range) {
			// restrict the handles of a range-slider from
			// going past one-another unless "pushy" is true
			if (index === 0 && value > values[1]) {
				if (pushy) {
					$$invalidate(0, values[1] = value, values);
				} else {
					value = values[1];
				}
			} else if (index === 1 && value < values[0]) {
				if (pushy) {
					$$invalidate(0, values[0] = value, values);
				} else {
					value = values[0];
				}
			}
		}

		// if the value has changed, update it
		if (values[index] !== value) {
			$$invalidate(0, values[index] = value, values);
		}

		// fire the change event when the handle moves,
		// and store the previous value for the next time
		if (previousValue !== value) {
			eChange();
			previousValue = value;
		}

		return value;
	}

	/**
 * helper to find the beginning range value for use with css style
 * @param {array} values the input values for the rangeSlider
 * @return {number} the beginning of the range
 **/
	function rangeStart(values) {
		if (range === "min") {
			return 0;
		} else {
			return values[0];
		}
	}

	/**
 * helper to find the ending range value for use with css style
 * @param {array} values the input values for the rangeSlider
 * @return {number} the end of the range
 **/
	function rangeEnd(values) {
		if (range === "max") {
			return 0;
		} else if (range === "min") {
			return 100 - values[0];
		} else {
			return 100 - values[1];
		}
	}

	/**
 * when the user has unfocussed (blurred) from the
 * slider, deactivate all handles
 * @param {event} e the event from browser
 **/
	function sliderBlurHandle(e) {
		if (keyboardActive) {
			$$invalidate(24, focus = false);
			handleActivated = false;
			$$invalidate(25, handlePressed = false);
		}
	}

	/**
 * when the user focusses the handle of a slider
 * set it to be active
 * @param {event} e the event from browser
 **/
	function sliderFocusHandle(e) {
		if (!disabled) {
			$$invalidate(26, activeHandle = index(e.target));
			$$invalidate(24, focus = true);
		}
	}

	/**
 * handle the keyboard accessible features by checking the
 * input type, and modfier key then moving handle by appropriate amount
 * @param {event} e the event from browser
 **/
	function sliderKeydown(e) {
		if (!disabled) {
			const handle = index(e.target);
			let jump = e.ctrlKey || e.metaKey || e.shiftKey ? step * 10 : step;
			let prevent = false;

			switch (e.key) {
				case "PageDown":
					jump *= 10;
				case "ArrowRight":
				case "ArrowUp":
					moveHandle(handle, values[handle] + jump);
					prevent = true;
					break;
				case "PageUp":
					jump *= 10;
				case "ArrowLeft":
				case "ArrowDown":
					moveHandle(handle, values[handle] - jump);
					prevent = true;
					break;
				case "Home":
					moveHandle(handle, min);
					prevent = true;
					break;
				case "End":
					moveHandle(handle, max);
					prevent = true;
					break;
			}

			if (prevent) {
				e.preventDefault();
				e.stopPropagation();
			}
		}
	}

	/**
 * function to run when the user touches
 * down on the slider element anywhere
 * @param {event} e the event from browser
 **/
	function sliderInteractStart(e) {
		if (!disabled) {
			const el = e.target;
			const clientPos = normalisedClient(e);

			// set the closest handle as active
			$$invalidate(24, focus = true);

			handleActivated = true;
			$$invalidate(25, handlePressed = true);
			$$invalidate(26, activeHandle = getClosestHandle(clientPos));

			// fire the start event
			startValue = previousValue = alignValueToStep(values[activeHandle]);

			eStart();

			// for touch devices we want the handle to instantly
			// move to the position touched for more responsive feeling
			if (e.type === "touchstart" && !el.matches(".pipVal")) {
				handleInteract(clientPos);
			}
		}
	}

	/**
 * function to run when the user stops touching
 * down on the slider element anywhere
 * @param {event} e the event from browser
 **/
	function sliderInteractEnd(e) {
		// fire the stop event for touch devices
		if (e.type === "touchend") {
			eStop();
		}

		$$invalidate(25, handlePressed = false);
	}

	/**
 * unfocus the slider if the user clicked off of
 * it, somewhere else on the screen
 * @param {event} e the event from browser
 **/
	function bodyInteractStart(e) {
		keyboardActive = false;

		if (focus && e.target !== slider && !slider.contains(e.target)) {
			$$invalidate(24, focus = false);
		}
	}

	/**
 * send the clientX through to handle the interaction
 * whenever the user moves acros screen while active
 * @param {event} e the event from browser
 **/
	function bodyInteract(e) {
		if (!disabled) {
			if (handleActivated) {
				handleInteract(normalisedClient(e));
			}
		}
	}

	/**
 * if user triggers mouseup on the body while
 * a handle is active (without moving) then we
 * trigger an interact event there
 * @param {event} e the event from browser
 **/
	function bodyMouseUp(e) {
		if (!disabled) {
			const el = e.target;

			// this only works if a handle is active, which can
			// only happen if there was sliderInteractStart triggered
			// on the slider, already
			if (handleActivated) {
				if (el === slider || slider.contains(el)) {
					$$invalidate(24, focus = true);

					// don't trigger interact if the target is a handle (no need) or
					// if the target is a label (we want to move to that value from rangePips)
					if (!targetIsHandle(el) && !el.matches(".pipVal")) {
						handleInteract(normalisedClient(e));
					}
				}

				// fire the stop event for mouse device
				// when the body is triggered with an active handle
				eStop();
			}
		}

		handleActivated = false;
		$$invalidate(25, handlePressed = false);
	}

	/**
 * if user triggers touchend on the body then we
 * defocus the slider completely
 * @param {event} e the event from browser
 **/
	function bodyTouchEnd(e) {
		handleActivated = false;
		$$invalidate(25, handlePressed = false);
	}

	function bodyKeyDown(e) {
		if (!disabled) {
			if (e.target === slider || slider.contains(e.target)) {
				keyboardActive = true;
			}
		}
	}

	function eStart() {
		!disabled && dispatch("start", {
			activeHandle,
			value: startValue,
			values: values.map(v => alignValueToStep(v))
		});
	}

	function eStop() {
		!disabled && dispatch("stop", {
			activeHandle,
			startValue,
			value: values[activeHandle],
			values: values.map(v => alignValueToStep(v))
		});
	}

	function eChange() {
		!disabled && dispatch("change", {
			activeHandle,
			startValue,
			previousValue: typeof previousValue === "undefined"
			? startValue
			: previousValue,
			value: values[activeHandle],
			values: values.map(v => alignValueToStep(v))
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			slider = $$value;
			$$invalidate(1, slider);
		});
	}

	$$self.$$set = $$props => {
		if ('slider' in $$props) $$invalidate(1, slider = $$props.slider);
		if ('range' in $$props) $$invalidate(2, range = $$props.range);
		if ('pushy' in $$props) $$invalidate(43, pushy = $$props.pushy);
		if ('min' in $$props) $$invalidate(3, min = $$props.min);
		if ('max' in $$props) $$invalidate(4, max = $$props.max);
		if ('step' in $$props) $$invalidate(5, step = $$props.step);
		if ('values' in $$props) $$invalidate(0, values = $$props.values);
		if ('vertical' in $$props) $$invalidate(6, vertical = $$props.vertical);
		if ('float' in $$props) $$invalidate(7, float = $$props.float);
		if ('reversed' in $$props) $$invalidate(8, reversed = $$props.reversed);
		if ('hoverable' in $$props) $$invalidate(9, hoverable = $$props.hoverable);
		if ('disabled' in $$props) $$invalidate(10, disabled = $$props.disabled);
		if ('pips' in $$props) $$invalidate(11, pips = $$props.pips);
		if ('pipstep' in $$props) $$invalidate(12, pipstep = $$props.pipstep);
		if ('all' in $$props) $$invalidate(13, all = $$props.all);
		if ('first' in $$props) $$invalidate(14, first = $$props.first);
		if ('last' in $$props) $$invalidate(15, last = $$props.last);
		if ('rest' in $$props) $$invalidate(16, rest = $$props.rest);
		if ('id' in $$props) $$invalidate(17, id = $$props.id);
		if ('prefix' in $$props) $$invalidate(18, prefix = $$props.prefix);
		if ('suffix' in $$props) $$invalidate(19, suffix = $$props.suffix);
		if ('formatter' in $$props) $$invalidate(20, formatter = $$props.formatter);
		if ('handleFormatter' in $$props) $$invalidate(21, handleFormatter = $$props.handleFormatter);
		if ('precision' in $$props) $$invalidate(44, precision = $$props.precision);
		if ('springValues' in $$props) $$invalidate(45, springValues = $$props.springValues);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*min, max*/ 24) {
			/**
 * clamp a value from the range so that it always
 * falls within the min/max values
 * @param {number} val the value to clamp
 * @return {number} the value after it's been clamped
 **/
			$$invalidate(48, clampValue = function (val) {
				// return the min/max if outside of that range
				return val <= min ? min : val >= max ? max : val;
			});
		}

		if ($$self.$$.dirty[0] & /*min, max, step*/ 56 | $$self.$$.dirty[1] & /*clampValue, precision*/ 139264) {
			/**
 * align the value with the steps so that it
 * always sits on the closest (above/below) step
 * @param {number} val the value to align
 * @return {number} the value after it's been aligned
 **/
			$$invalidate(47, alignValueToStep = function (val) {
				// sanity check for performance
				if (val <= min) {
					return min;
				} else if (val >= max) {
					return max;
				}

				// find the middle-point between steps
				// and see if the value is closer to the
				// next step, or previous step
				let remainder = (val - min) % step;

				let aligned = val - remainder;

				if (Math.abs(remainder) * 2 >= step) {
					aligned += remainder > 0 ? step : -step;
				}

				// make sure the value is within acceptable limits
				aligned = clampValue(aligned);

				// make sure the returned value is set to the precision desired
				// this is also because javascript often returns weird floats
				// when dealing with odd numbers and percentages
				return parseFloat(aligned.toFixed(precision));
			});
		}

		if ($$self.$$.dirty[0] & /*min, max*/ 24 | $$self.$$.dirty[1] & /*precision*/ 8192) {
			/**
 * take in a value, and then calculate that value's percentage
 * of the overall range (min-max);
 * @param {number} val the value we're getting percent for
 * @return {number} the percentage value
 **/
			$$invalidate(23, percentOf = function (val) {
				let perc = (val - min) / (max - min) * 100;

				if (isNaN(perc) || perc <= 0) {
					return 0;
				} else if (perc >= 100) {
					return 100;
				} else {
					return parseFloat(perc.toFixed(precision));
				}
			});
		}

		if ($$self.$$.dirty[0] & /*values, max, min, percentOf, springPositions*/ 12582937 | $$self.$$.dirty[1] & /*alignValueToStep, valueLength, springValues*/ 114688) {
			{
				// check that "values" is an array, or set it as array
				// to prevent any errors in springs, or range trimming
				if (!Array.isArray(values)) {
					$$invalidate(0, values = [(max + min) / 2]);
					console.error("'values' prop should be an Array (https://github.com/simeydotme/svelte-range-slider-pips#slider-props)");
				}

				// trim the range so it remains as a min/max (only 2 handles)
				// and also align the handles to the steps
				$$invalidate(0, values = trimRange(values.map(v => alignValueToStep(v))));

				// check if the valueLength (length of values[]) has changed,
				// because if so we need to re-seed the spring function with the
				// new values array.
				if (valueLength !== values.length) {
					// set the initial spring values when the slider initialises,
					// or when values array length has changed
					$$subscribe_springPositions($$invalidate(22, springPositions = spring(values.map(v => percentOf(v)), springValues)));
				} else {
					// update the value of the spring function for animated handles
					// whenever the values has updated
					springPositions.set(values.map(v => percentOf(v)));
				}

				// set the valueLength for the next check
				$$invalidate(46, valueLength = values.length);
			}
		}

		if ($$self.$$.dirty[0] & /*vertical, reversed*/ 320) {
			/**
 * the orientation of the handles/pips based on the
 * input values of vertical and reversed
 **/
			$$invalidate(28, orientationStart = vertical
			? reversed ? 'top' : 'bottom'
			: reversed ? 'right' : 'left');
		}

		if ($$self.$$.dirty[0] & /*vertical, reversed*/ 320) {
			$$invalidate(27, orientationEnd = vertical
			? reversed ? 'bottom' : 'top'
			: reversed ? 'left' : 'right');
		}
	};

	return [
		values,
		slider,
		range,
		min,
		max,
		step,
		vertical,
		float,
		reversed,
		hoverable,
		disabled,
		pips,
		pipstep,
		all,
		first,
		last,
		rest,
		id,
		prefix,
		suffix,
		formatter,
		handleFormatter,
		springPositions,
		percentOf,
		focus,
		handlePressed,
		activeHandle,
		orientationEnd,
		orientationStart,
		$springPositions,
		moveHandle,
		rangeStart,
		rangeEnd,
		sliderBlurHandle,
		sliderFocusHandle,
		sliderKeydown,
		sliderInteractStart,
		sliderInteractEnd,
		bodyInteractStart,
		bodyInteract,
		bodyMouseUp,
		bodyTouchEnd,
		bodyKeyDown,
		pushy,
		precision,
		springValues,
		valueLength,
		alignValueToStep,
		clampValue,
		div_binding
	];
}

class RangeSlider extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$3,
			create_fragment$3,
			safe_not_equal,
			{
				slider: 1,
				range: 2,
				pushy: 43,
				min: 3,
				max: 4,
				step: 5,
				values: 0,
				vertical: 6,
				float: 7,
				reversed: 8,
				hoverable: 9,
				disabled: 10,
				pips: 11,
				pipstep: 12,
				all: 13,
				first: 14,
				last: 15,
				rest: 16,
				id: 17,
				prefix: 18,
				suffix: 19,
				formatter: 20,
				handleFormatter: 21,
				precision: 44,
				springValues: 45
			},
			null,
			[-1, -1, -1]
		);
	}
}

/* home/runner/work/gradio/gradio/ui/packages/audio/src/Audio.svelte generated by Svelte v3.49.0 */

function create_else_block_1(ctx) {
	let modifyupload;
	let t0;
	let audio;
	let audio_src_value;
	let t1;
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;

	modifyupload = new ModifyUpload({
			props: { editable: true, absolute: false }
		});

	modifyupload.$on("clear", /*clear*/ ctx[15]);
	modifyupload.$on("edit", /*edit_handler*/ ctx[25]);
	let if_block = /*mode*/ ctx[10] === "edit" && /*player*/ ctx[11]?.duration && create_if_block_4(ctx);

	return {
		c() {
			create_component(modifyupload.$$.fragment);
			t0 = space();
			audio = element("audio");
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			attr(audio, "class", "w-full h-14 p-2");
			audio.controls = true;
			attr(audio, "preload", "metadata");
			if (!src_url_equal(audio.src, audio_src_value = /*value*/ ctx[1].data)) attr(audio, "src", audio_src_value);
		},
		m(target, anchor) {
			mount_component(modifyupload, target, anchor);
			insert(target, t0, anchor);
			insert(target, audio, anchor);
			/*audio_binding*/ ctx[26](audio);
			insert(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(/*loaded*/ ctx[16].call(null, audio)),
					listen(audio, "play", /*play_handler*/ ctx[21]),
					listen(audio, "pause", /*pause_handler*/ ctx[22]),
					listen(audio, "ended", /*ended_handler*/ ctx[23])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (!current || dirty[0] & /*value*/ 2 && !src_url_equal(audio.src, audio_src_value = /*value*/ ctx[1].data)) {
				attr(audio, "src", audio_src_value);
			}

			if (/*mode*/ ctx[10] === "edit" && /*player*/ ctx[11]?.duration) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*mode, player*/ 3072) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_4(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(modifyupload.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(modifyupload.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(modifyupload, detaching);
			if (detaching) detach(t0);
			if (detaching) detach(audio);
			/*audio_binding*/ ctx[26](null);
			if (detaching) detach(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (129:0) {#if value === null || streaming}
function create_if_block$2(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1, create_if_block_3];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*source*/ ctx[4] === "microphone") return 0;
		if (/*source*/ ctx[4] === "upload") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_1(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

// (184:1) {#if mode === "edit" && player?.duration}
function create_if_block_4(ctx) {
	let range;
	let updating_values;
	let current;

	function range_values_binding(value) {
		/*range_values_binding*/ ctx[27](value);
	}

	let range_props = { range: true, min: 0, max: 100, step: 1 };

	if (/*crop_values*/ ctx[12] !== void 0) {
		range_props.values = /*crop_values*/ ctx[12];
	}

	range = new RangeSlider({ props: range_props });
	binding_callbacks.push(() => bind(range, 'values', range_values_binding));
	range.$on("change", /*handle_change*/ ctx[17]);

	return {
		c() {
			create_component(range.$$.fragment);
		},
		m(target, anchor) {
			mount_component(range, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const range_changes = {};

			if (!updating_values && dirty[0] & /*crop_values*/ 4096) {
				updating_values = true;
				range_changes.values = /*crop_values*/ ctx[12];
				add_flush_callback(() => updating_values = false);
			}

			range.$set(range_changes);
		},
		i(local) {
			if (current) return;
			transition_in(range.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(range.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(range, detaching);
		}
	};
}

// (155:31) 
function create_if_block_3(ctx) {
	let upload;
	let updating_dragging;
	let current;

	function upload_dragging_binding(value) {
		/*upload_dragging_binding*/ ctx[24](value);
	}

	let upload_props = {
		filetype: "audio/*",
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	};

	if (/*dragging*/ ctx[0] !== void 0) {
		upload_props.dragging = /*dragging*/ ctx[0];
	}

	upload = new Upload({ props: upload_props });
	binding_callbacks.push(() => bind(upload, 'dragging', upload_dragging_binding));
	upload.$on("load", /*handle_load*/ ctx[18]);

	return {
		c() {
			create_component(upload.$$.fragment);
		},
		m(target, anchor) {
			mount_component(upload, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const upload_changes = {};

			if (dirty[0] & /*upload_text, or_text, drop_text*/ 448 | dirty[1] & /*$$scope*/ 8) {
				upload_changes.$$scope = { dirty, ctx };
			}

			if (!updating_dragging && dirty[0] & /*dragging*/ 1) {
				updating_dragging = true;
				upload_changes.dragging = /*dragging*/ ctx[0];
				add_flush_callback(() => updating_dragging = false);
			}

			upload.$set(upload_changes);
		},
		i(local) {
			if (current) return;
			transition_in(upload.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(upload.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(upload, detaching);
		}
	};
}

// (130:1) {#if source === "microphone"}
function create_if_block_1(ctx) {
	let div;

	function select_block_type_2(ctx, dirty) {
		if (/*recording*/ ctx[9]) return create_if_block_2;
		return create_else_block$2;
	}

	let current_block_type = select_block_type_2(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", "mt-6 p-2");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_block.m(div, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			if_block.d();
		}
	};
}

// (156:2) <Upload filetype="audio/*" on:load={handle_load} bind:dragging>
function create_default_slot$1(ctx) {
	let div;
	let t0;
	let t1;
	let span;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;

	return {
		c() {
			div = element("div");
			t0 = text(/*drop_text*/ ctx[6]);
			t1 = space();
			span = element("span");
			t2 = text("- ");
			t3 = text(/*or_text*/ ctx[7]);
			t4 = text(" -");
			t5 = space();
			t6 = text(/*upload_text*/ ctx[8]);
			attr(span, "class", "text-gray-300");
			attr(div, "class", "flex flex-col");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);
			append(div, span);
			append(span, t2);
			append(span, t3);
			append(span, t4);
			append(div, t5);
			append(div, t6);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*drop_text*/ 64) set_data(t0, /*drop_text*/ ctx[6]);
			if (dirty[0] & /*or_text*/ 128) set_data(t3, /*or_text*/ ctx[7]);
			if (dirty[0] & /*upload_text*/ 256) set_data(t6, /*upload_text*/ ctx[8]);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (144:3) {:else}
function create_else_block$2(ctx) {
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");

			button.innerHTML = `<span class="flex h-1.5 w-1.5 relative mr-2"><span class="relative inline-flex rounded-full h-1.5 w-1.5 bg-red-500"></span></span> 
					<div class="whitespace-nowrap">Record from microphone</div>`;

			attr(button, "class", "gr-button text-gray-800");
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*record*/ ctx[13]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (132:3) {#if recording}
function create_if_block_2(ctx) {
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");

			button.innerHTML = `<span class="flex h-1.5 w-1.5 relative mr-2 "><span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"></span> 
						<span class="relative inline-flex rounded-full h-1.5 w-1.5 bg-red-500"></span></span> 
					<div class="whitespace-nowrap text-red-500">Stop recording</div>`;

			attr(button, "class", "gr-button !bg-red-500/10");
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*stop*/ ctx[14]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$2(ctx) {
	let blocklabel;
	let t;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	blocklabel = new BlockLabel({
			props: {
				show_label: /*show_label*/ ctx[3],
				Icon: Music,
				label: /*label*/ ctx[2] || "Audio"
			}
		});

	const if_block_creators = [create_if_block$2, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*value*/ ctx[1] === null || /*streaming*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			create_component(blocklabel.$$.fragment);
			t = space();
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(blocklabel, target, anchor);
			insert(target, t, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const blocklabel_changes = {};
			if (dirty[0] & /*show_label*/ 8) blocklabel_changes.show_label = /*show_label*/ ctx[3];
			if (dirty[0] & /*label*/ 4) blocklabel_changes.label = /*label*/ ctx[2] || "Audio";
			blocklabel.$set(blocklabel_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(blocklabel.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(blocklabel.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(blocklabel, detaching);
			if (detaching) detach(t);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function blob_to_data_url(blob) {
	return new Promise((fulfill, reject) => {
			let reader = new FileReader();
			reader.onerror = reject;
			reader.onload = () => fulfill(reader.result);
			reader.readAsDataURL(blob);
		});
}

function instance$2($$self, $$props, $$invalidate) {
	let { value = null } = $$props;
	let { label } = $$props;
	let { show_label } = $$props;
	let { name } = $$props;
	let { source } = $$props;
	let { pending = false } = $$props;
	let { streaming = false } = $$props;
	let { drop_text = "Drop an audio file" } = $$props;
	let { or_text = "or" } = $$props;
	let { upload_text = "click to upload" } = $$props;

	// TODO: make use of this
	// export let type: "normal" | "numpy" = "normal";
	let recording = false;

	let recorder;
	let mode = "";
	let audio_chunks = [];
	let audio_blob;
	let player;
	let inited = false;
	let crop_values = [0, 100];
	const dispatch = createEventDispatcher();

	async function prepare_audio() {
		const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
		recorder = new MediaRecorder(stream);

		recorder.addEventListener("dataavailable", event => {
			audio_chunks.push(event.data);
		});

		recorder.addEventListener("stop", async () => {
			if (!streaming) {
				$$invalidate(9, recording = false);
			}

			audio_blob = new Blob(audio_chunks, { type: "audio/wav" });
			audio_chunks = [];

			$$invalidate(1, value = {
				data: await blob_to_data_url(audio_blob),
				name
			});

			dispatch(streaming ? "stream" : "change", value);
		});

		inited = true;
	}

	async function record() {
		$$invalidate(9, recording = true);
		audio_chunks = [];
		if (!inited) await prepare_audio();
		recorder.start();
	}

	onDestroy(() => {
		if (recorder && recorder.state !== "inactive") {
			recorder.stop();
		}
	});

	const stop = () => {
		recorder.stop();

		if (streaming) {
			$$invalidate(9, recording = false);
		}
	};

	function clear() {
		dispatch("change");
		$$invalidate(10, mode = "");
		$$invalidate(1, value = null);
	}

	function loaded(node) {
		function clamp_playback() {
			const start_time = crop_values[0] / 100 * node.duration;
			const end_time = crop_values[1] / 100 * node.duration;

			if (node.currentTime < start_time) {
				node.currentTime = start_time;
			}

			if (node.currentTime > end_time) {
				node.currentTime = start_time;
				node.pause();
			}
		}

		node.addEventListener("timeupdate", clamp_playback);

		return {
			destroy: () => node.removeEventListener("timeupdate", clamp_playback)
		};
	}

	function handle_change({ detail: { values } }) {
		if (!value) return;

		dispatch("change", {
			data: value.data,
			name,
			crop_min: values[0],
			crop_max: values[1]
		});

		dispatch("edit");
	}

	function handle_load({ detail }) {
		$$invalidate(1, value = detail);
		dispatch("change", { data: detail.data, name: detail.name });
	}

	let { dragging = false } = $$props;

	if (streaming) {
		window.setInterval(
			() => {
				if (recording && recorder && recorder.state === "recording" && pending === false) {
					stop();
					record();
				}
			},
			500
		);
	}

	function play_handler(event) {
		bubble.call(this, $$self, event);
	}

	function pause_handler(event) {
		bubble.call(this, $$self, event);
	}

	function ended_handler(event) {
		bubble.call(this, $$self, event);
	}

	function upload_dragging_binding(value) {
		dragging = value;
		$$invalidate(0, dragging);
	}

	const edit_handler = () => $$invalidate(10, mode = "edit");

	function audio_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			player = $$value;
			$$invalidate(11, player);
		});
	}

	function range_values_binding(value) {
		crop_values = value;
		$$invalidate(12, crop_values);
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('show_label' in $$props) $$invalidate(3, show_label = $$props.show_label);
		if ('name' in $$props) $$invalidate(19, name = $$props.name);
		if ('source' in $$props) $$invalidate(4, source = $$props.source);
		if ('pending' in $$props) $$invalidate(20, pending = $$props.pending);
		if ('streaming' in $$props) $$invalidate(5, streaming = $$props.streaming);
		if ('drop_text' in $$props) $$invalidate(6, drop_text = $$props.drop_text);
		if ('or_text' in $$props) $$invalidate(7, or_text = $$props.or_text);
		if ('upload_text' in $$props) $$invalidate(8, upload_text = $$props.upload_text);
		if ('dragging' in $$props) $$invalidate(0, dragging = $$props.dragging);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*dragging*/ 1) {
			dispatch("drag", dragging);
		}
	};

	return [
		dragging,
		value,
		label,
		show_label,
		source,
		streaming,
		drop_text,
		or_text,
		upload_text,
		recording,
		mode,
		player,
		crop_values,
		record,
		stop,
		clear,
		loaded,
		handle_change,
		handle_load,
		name,
		pending,
		play_handler,
		pause_handler,
		ended_handler,
		upload_dragging_binding,
		edit_handler,
		audio_binding,
		range_values_binding
	];
}

class Audio extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$2,
			create_fragment$2,
			safe_not_equal,
			{
				value: 1,
				label: 2,
				show_label: 3,
				name: 19,
				source: 4,
				pending: 20,
				streaming: 5,
				drop_text: 6,
				or_text: 7,
				upload_text: 8,
				dragging: 0
			},
			null,
			[-1, -1]
		);
	}
}

/* home/runner/work/gradio/gradio/ui/packages/audio/src/StaticAudio.svelte generated by Svelte v3.49.0 */

function create_else_block$1(ctx) {
	let audio;
	let audio_src_value;
	let mounted;
	let dispose;

	return {
		c() {
			audio = element("audio");
			attr(audio, "class", "w-full h-14 p-2 mt-7");
			audio.controls = true;
			attr(audio, "preload", "metadata");
			if (!src_url_equal(audio.src, audio_src_value = /*value*/ ctx[0].data)) attr(audio, "src", audio_src_value);
		},
		m(target, anchor) {
			insert(target, audio, anchor);

			if (!mounted) {
				dispose = [
					listen(audio, "play", /*play_handler*/ ctx[4]),
					listen(audio, "pause", /*pause_handler*/ ctx[5]),
					listen(audio, "ended", /*ended_handler*/ ctx[6])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 1 && !src_url_equal(audio.src, audio_src_value = /*value*/ ctx[0].data)) {
				attr(audio, "src", audio_src_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(audio);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (19:0) {#if value === null}
function create_if_block$1(ctx) {
	let div1;
	let div0;
	let music;
	let current;
	music = new Music({});

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			create_component(music.$$.fragment);
			attr(div0, "class", "h-5 dark:text-white opacity-50");
			attr(div1, "class", "h-full min-h-[8rem] flex justify-center items-center");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			mount_component(music, div0, null);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(music.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(music.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(music);
		}
	};
}

function create_fragment$1(ctx) {
	let blocklabel;
	let t;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	blocklabel = new BlockLabel({
			props: {
				show_label: /*show_label*/ ctx[2],
				Icon: Music,
				label: /*label*/ ctx[1] || "Audio"
			}
		});

	const if_block_creators = [create_if_block$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*value*/ ctx[0] === null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			create_component(blocklabel.$$.fragment);
			t = space();
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(blocklabel, target, anchor);
			insert(target, t, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const blocklabel_changes = {};
			if (dirty & /*show_label*/ 4) blocklabel_changes.show_label = /*show_label*/ ctx[2];
			if (dirty & /*label*/ 2) blocklabel_changes.label = /*label*/ ctx[1] || "Audio";
			blocklabel.$set(blocklabel_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(blocklabel.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(blocklabel.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(blocklabel, detaching);
			if (detaching) detach(t);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { value = null } = $$props;
	let { label } = $$props;
	let { name } = $$props;
	let { show_label } = $$props;
	const dispatch = createEventDispatcher();

	function play_handler(event) {
		bubble.call(this, $$self, event);
	}

	function pause_handler(event) {
		bubble.call(this, $$self, event);
	}

	function ended_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('name' in $$props) $$invalidate(3, name = $$props.name);
		if ('show_label' in $$props) $$invalidate(2, show_label = $$props.show_label);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value, name*/ 9) {
			value && dispatch("change", { name, data: value?.data });
		}
	};

	return [value, label, show_label, name, play_handler, pause_handler, ended_handler];
}

class StaticAudio extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			value: 0,
			label: 1,
			name: 3,
			show_label: 2
		});
	}
}

/* src/components/Audio/Audio.svelte generated by Svelte v3.49.0 */

function create_else_block(ctx) {
	let staticaudio;
	let current;

	staticaudio = new StaticAudio({
			props: {
				show_label: /*show_label*/ ctx[8],
				value: /*_value*/ ctx[12],
				name: /*_value*/ ctx[12]?.name || "audio_file",
				label: /*label*/ ctx[7]
			}
		});

	return {
		c() {
			create_component(staticaudio.$$.fragment);
		},
		m(target, anchor) {
			mount_component(staticaudio, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const staticaudio_changes = {};
			if (dirty & /*show_label*/ 256) staticaudio_changes.show_label = /*show_label*/ ctx[8];
			if (dirty & /*_value*/ 4096) staticaudio_changes.value = /*_value*/ ctx[12];
			if (dirty & /*_value*/ 4096) staticaudio_changes.name = /*_value*/ ctx[12]?.name || "audio_file";
			if (dirty & /*label*/ 128) staticaudio_changes.label = /*label*/ ctx[7];
			staticaudio.$set(staticaudio_changes);
		},
		i(local) {
			if (current) return;
			transition_in(staticaudio.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(staticaudio.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(staticaudio, detaching);
		}
	};
}

// (38:1) {#if mode === "dynamic"}
function create_if_block(ctx) {
	let audio;
	let current;

	audio = new Audio({
			props: {
				label: /*label*/ ctx[7],
				show_label: /*show_label*/ ctx[8],
				value: /*_value*/ ctx[12],
				name: /*name*/ ctx[5],
				source: /*source*/ ctx[6],
				pending: /*pending*/ ctx[9],
				streaming: /*streaming*/ ctx[10],
				drop_text: /*$_*/ ctx[14]("interface.drop_audio"),
				or_text: /*$_*/ ctx[14]("or"),
				upload_text: /*$_*/ ctx[14]("interface.click_to_upload")
			}
		});

	audio.$on("change", /*change_handler*/ ctx[17]);
	audio.$on("stream", /*stream_handler*/ ctx[18]);
	audio.$on("drag", /*drag_handler*/ ctx[19]);
	audio.$on("edit", /*edit_handler*/ ctx[20]);
	audio.$on("play", /*play_handler*/ ctx[21]);
	audio.$on("pause", /*pause_handler*/ ctx[22]);
	audio.$on("ended", /*ended_handler*/ ctx[23]);

	return {
		c() {
			create_component(audio.$$.fragment);
		},
		m(target, anchor) {
			mount_component(audio, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const audio_changes = {};
			if (dirty & /*label*/ 128) audio_changes.label = /*label*/ ctx[7];
			if (dirty & /*show_label*/ 256) audio_changes.show_label = /*show_label*/ ctx[8];
			if (dirty & /*_value*/ 4096) audio_changes.value = /*_value*/ ctx[12];
			if (dirty & /*name*/ 32) audio_changes.name = /*name*/ ctx[5];
			if (dirty & /*source*/ 64) audio_changes.source = /*source*/ ctx[6];
			if (dirty & /*pending*/ 512) audio_changes.pending = /*pending*/ ctx[9];
			if (dirty & /*streaming*/ 1024) audio_changes.streaming = /*streaming*/ ctx[10];
			if (dirty & /*$_*/ 16384) audio_changes.drop_text = /*$_*/ ctx[14]("interface.drop_audio");
			if (dirty & /*$_*/ 16384) audio_changes.or_text = /*$_*/ ctx[14]("or");
			if (dirty & /*$_*/ 16384) audio_changes.upload_text = /*$_*/ ctx[14]("interface.click_to_upload");
			audio.$set(audio_changes);
		},
		i(local) {
			if (current) return;
			transition_in(audio.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(audio.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(audio, detaching);
		}
	};
}

// (26:0) <Block  variant={mode === "dynamic" && value === null && source === "upload"   ? "dashed"   : "solid"}  color={dragging ? "green" : "grey"}  padding={false}  {elem_id}  {visible}  style={{ rounded: style.rounded }} >
function create_default_slot(ctx) {
	let statustracker;
	let t;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const statustracker_spread_levels = [/*loading_status*/ ctx[11]];
	let statustracker_props = {};

	for (let i = 0; i < statustracker_spread_levels.length; i += 1) {
		statustracker_props = assign(statustracker_props, statustracker_spread_levels[i]);
	}

	statustracker = new StatusTracker({ props: statustracker_props });
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*mode*/ ctx[4] === "dynamic") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			create_component(statustracker.$$.fragment);
			t = space();
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(statustracker, target, anchor);
			insert(target, t, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const statustracker_changes = (dirty & /*loading_status*/ 2048)
			? get_spread_update(statustracker_spread_levels, [get_spread_object(/*loading_status*/ ctx[11])])
			: {};

			statustracker.$set(statustracker_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(statustracker.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(statustracker.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(statustracker, detaching);
			if (detaching) detach(t);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment(ctx) {
	let block;
	let current;

	block = new Block({
			props: {
				variant: /*mode*/ ctx[4] === "dynamic" && /*value*/ ctx[0] === null && /*source*/ ctx[6] === "upload"
				? "dashed"
				: "solid",
				color: /*dragging*/ ctx[13] ? "green" : "grey",
				padding: false,
				elem_id: /*elem_id*/ ctx[2],
				visible: /*visible*/ ctx[3],
				style: { rounded: /*style*/ ctx[1].rounded },
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(block.$$.fragment);
		},
		m(target, anchor) {
			mount_component(block, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const block_changes = {};

			if (dirty & /*mode, value, source*/ 81) block_changes.variant = /*mode*/ ctx[4] === "dynamic" && /*value*/ ctx[0] === null && /*source*/ ctx[6] === "upload"
			? "dashed"
			: "solid";

			if (dirty & /*dragging*/ 8192) block_changes.color = /*dragging*/ ctx[13] ? "green" : "grey";
			if (dirty & /*elem_id*/ 4) block_changes.elem_id = /*elem_id*/ ctx[2];
			if (dirty & /*visible*/ 8) block_changes.visible = /*visible*/ ctx[3];
			if (dirty & /*style*/ 2) block_changes.style = { rounded: /*style*/ ctx[1].rounded };

			if (dirty & /*$$scope, label, show_label, _value, name, source, pending, streaming, $_, value, dragging, mode, loading_status*/ 16809969) {
				block_changes.$$scope = { dirty, ctx };
			}

			block.$set(block_changes);
		},
		i(local) {
			if (current) return;
			transition_in(block.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(block.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(block, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $_;
	component_subscribe($$self, X, $$value => $$invalidate(14, $_ = $$value));
	let { style = {} } = $$props;
	const dispatch = createEventDispatcher();
	let { elem_id = "" } = $$props;
	let { visible = true } = $$props;
	let { mode } = $$props;
	let { value = null } = $$props;
	let { name } = $$props;
	let { source } = $$props;
	let { label } = $$props;
	let { root } = $$props;
	let { show_label } = $$props;
	let { pending } = $$props;
	let { streaming } = $$props;
	let { loading_status } = $$props;
	let _value;
	let dragging;

	const change_handler = ({ detail }) => {
		$$invalidate(0, value = detail);
		dispatch("change", value);
	};

	const stream_handler = ({ detail }) => {
		$$invalidate(0, value = detail);
		dispatch("stream", value);
	};

	const drag_handler = ({ detail }) => $$invalidate(13, dragging = detail);

	function edit_handler(event) {
		bubble.call(this, $$self, event);
	}

	function play_handler(event) {
		bubble.call(this, $$self, event);
	}

	function pause_handler(event) {
		bubble.call(this, $$self, event);
	}

	function ended_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('style' in $$props) $$invalidate(1, style = $$props.style);
		if ('elem_id' in $$props) $$invalidate(2, elem_id = $$props.elem_id);
		if ('visible' in $$props) $$invalidate(3, visible = $$props.visible);
		if ('mode' in $$props) $$invalidate(4, mode = $$props.mode);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('name' in $$props) $$invalidate(5, name = $$props.name);
		if ('source' in $$props) $$invalidate(6, source = $$props.source);
		if ('label' in $$props) $$invalidate(7, label = $$props.label);
		if ('root' in $$props) $$invalidate(16, root = $$props.root);
		if ('show_label' in $$props) $$invalidate(8, show_label = $$props.show_label);
		if ('pending' in $$props) $$invalidate(9, pending = $$props.pending);
		if ('streaming' in $$props) $$invalidate(10, streaming = $$props.streaming);
		if ('loading_status' in $$props) $$invalidate(11, loading_status = $$props.loading_status);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value, root*/ 65537) {
			$$invalidate(12, _value = normalise_file(value, root));
		}
	};

	return [
		value,
		style,
		elem_id,
		visible,
		mode,
		name,
		source,
		label,
		show_label,
		pending,
		streaming,
		loading_status,
		_value,
		dragging,
		$_,
		dispatch,
		root,
		change_handler,
		stream_handler,
		drag_handler,
		edit_handler,
		play_handler,
		pause_handler,
		ended_handler
	];
}

class Audio_1 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			style: 1,
			elem_id: 2,
			visible: 3,
			mode: 4,
			value: 0,
			name: 5,
			source: 6,
			label: 7,
			root: 16,
			show_label: 8,
			pending: 9,
			streaming: 10,
			loading_status: 11
		});
	}
}

var Audio_1$1 = Audio_1;

const modes = ["static", "dynamic"];

export { Audio_1$1 as Component, modes };
